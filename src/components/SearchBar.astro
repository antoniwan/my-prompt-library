---
import { getCollection } from "astro:content";

interface Props {
	class?: string;
	placeholder?: string;
}

const {
	class: className = "",
	placeholder = "Search prompts, tags, pages‚Ä¶",
} = Astro.props as Props;

const prompts = await getCollection("prompts", ({ data }) => data.visibility === "public");

const promptSearchData = prompts.map((entry) => ({
	type: "prompt" as const,
	id: entry.id,
	title: entry.data.title,
	description: entry.data.summary || "",
	url: `/prompts/${entry.id}/`,
	tags: entry.data.tags,
	difficulty: entry.data.difficulty,
	author: entry.data.author,
}));

const tagCounts = new Map<string, number>();
for (const entry of prompts) {
	for (const tag of entry.data.tags) {
		tagCounts.set(tag, (tagCounts.get(tag) ?? 0) + 1);
	}
}

const tagSearchData = Array.from(tagCounts.entries()).map(([tag, count]) => ({
	type: "tag" as const,
	id: tag,
	title: tag,
	description: `${count} prompt${count === 1 ? "" : "s"} tagged "${tag}"`,
	url: `/tags/${encodeURIComponent(tag)}/`,
	count,
}));

const pageSearchData = [
	{
		type: "page" as const,
		id: "home",
		title: "Home",
		description: "Overview of My Prompt Library",
		url: "/",
	},
	{
		type: "page" as const,
		id: "prompts",
		title: "Prompts",
		description: "Browse all prompts",
		url: "/prompts/",
	},
	{
		type: "page" as const,
		id: "tags",
		title: "Tags",
		description: "Browse all tags",
		url: "/tags/",
	},
	{
		type: "page" as const,
		id: "search",
		title: "Search",
		description: "Full-page search interface",
		url: "/search/",
	},
];

const searchData = [...promptSearchData, ...tagSearchData, ...pageSearchData];

const searchId = `search-${Math.random().toString(36).slice(2, 9)}`;
---

<div class={`mpl-search-root ${className}`.trim()} data-search-root>
	<div class="mpl-search-input-wrapper">
		<span class="mpl-search-icon" aria-hidden="true">üîç</span>
		<label class="mpl-search-label">
			<span class="visually-hidden">Search prompts, tags, and pages</span>
			<input
				id={searchId}
				type="search"
				class="mpl-search-input"
				placeholder={placeholder}
				autocomplete="off"
				spellcheck="false"
				role="combobox"
				aria-expanded="false"
				aria-autocomplete="list"
				aria-controls={`${searchId}-results`}
			/>
		</label>
		<button
			id={`${searchId}-clear`}
			type="button"
			class="mpl-search-clear hidden"
			aria-label="Clear search"
		>
			√ó
		</button>
	</div>

	<div
		id={`${searchId}-results`}
		class="mpl-search-dropdown hidden"
		role="listbox"
		aria-label="Search results"
	>
		<div id={`${searchId}-loading`} class="mpl-search-state mpl-search-loading hidden">
			<span class="mpl-search-spinner" aria-hidden="true"></span>
			<span>Searching‚Ä¶</span>
		</div>
		<div id={`${searchId}-no-results`} class="mpl-search-state mpl-search-empty hidden">
			<p class="mpl-search-empty-title">No results found</p>
			<p class="mpl-search-empty-hint">Try another keyword, tag, or page name.</p>
		</div>
		<div id={`${searchId}-results-list`} class="mpl-search-results-list"></div>
	</div>
</div>

<script define:vars={{ searchData }}>
	class SearchBar {
		constructor(root, data) {
			this.root = root;
			this.input = root.querySelector(".mpl-search-input");
			this.results = root.querySelector(".mpl-search-dropdown");
			this.resultsList = root.querySelector(".mpl-search-results-list");
			this.loading = root.querySelector(".mpl-search-loading");
			this.noResults = root.querySelector(".mpl-search-empty");
			this.clearBtn = root.querySelector(".mpl-search-clear");
			this.data = Array.isArray(data) ? data : [];
			this.debounceTimer = null;
			this.isSearching = false;

			this.init();
		}

		init() {
			if (!this.input) return;

			this.input.addEventListener("input", () => this.handleInput());

			this.input.addEventListener("focus", () => {
				if (this.input && this.input.value.trim() && this.resultsList?.children.length) {
					this.showResults();
				}
			});

			if (this.clearBtn) {
				this.clearBtn.addEventListener("click", () => this.clearSearch());
			}

			document.addEventListener("click", (event) => {
				if (!this.root.contains(event.target)) {
					this.hideResults();
				}
			});

			this.input.addEventListener("keydown", (event) => {
				if (event.key === "Escape") {
					this.hideResults();
					this.input?.blur();
				} else if (event.key === "ArrowDown" || event.key === "ArrowUp") {
					event.preventDefault();
					this.handleArrowKeys(event.key);
				} else if (event.key === "Enter") {
					event.preventDefault();
					this.handleEnterKey();
				}
			});
		}

		handleInput() {
			const query = this.input?.value.trim() ?? "";

			if (this.clearBtn) {
				this.clearBtn.classList.toggle("hidden", query.length === 0);
			}

			if (this.debounceTimer) {
				clearTimeout(this.debounceTimer);
			}

			this.debounceTimer = setTimeout(() => {
				if (query.length >= 2) {
					this.performSearch(query);
				} else {
					this.hideResults();
				}
			}, 200);
		}

		performSearch(query) {
			if (this.isSearching) return;
			this.isSearching = true;

			this.showLoading();

			try {
				const results = this.search(query);
				this.displayResults(results);
			} catch {
				this.showNoResults();
			} finally {
				this.isSearching = false;
			}
		}

		search(query) {
			const searchData = this.data;
			if (!Array.isArray(searchData) || searchData.length === 0) return [];

			const normalized = query.toLowerCase().trim();

			const filtered = searchData.filter((item) => {
				const titleMatch = item.title?.toLowerCase().includes(normalized);
				const descriptionMatch = item.description?.toLowerCase().includes(normalized);

				let extraMatch = false;

				if (item.type === "prompt") {
					const tagsMatch = (item.tags ?? []).some((tag) =>
						tag.toLowerCase().includes(normalized),
					);
					const difficultyMatch = item.difficulty
						?.toLowerCase()
						.includes(normalized);
					const authorMatch = item.author?.toLowerCase().includes(normalized);
					extraMatch = tagsMatch || difficultyMatch || authorMatch;
				} else if (item.type === "tag") {
					extraMatch = item.id?.toLowerCase().includes(normalized);
				}

				return titleMatch || descriptionMatch || extraMatch;
			});

			const scored = filtered.map((item) => {
				let score = 0;

				const titleMatch = item.title?.toLowerCase().includes(normalized);
				const descriptionMatch = item.description?.toLowerCase().includes(normalized);

				if (titleMatch) score += 10;
				if (descriptionMatch) score += 5;

				if (item.type === "prompt") {
					score += 4;
					if ((item.tags ?? []).some((tag) => tag.toLowerCase().includes(normalized))) {
						score += 2;
					}
					if (item.author && item.author.toLowerCase().includes(normalized)) {
						score += 1;
					}
					if (
						item.difficulty &&
						item.difficulty.toLowerCase().includes(normalized)
					) {
						score += 1;
					}
				} else if (item.type === "tag") {
					score += 3;
					if (item.count && item.count > 3) score += 1;
				} else if (item.type === "page") {
					score += 1;
				}

				return { ...item, score };
			});

			scored.sort((a, b) => {
				if (b.score !== a.score) return b.score - a.score;
				return a.title.length - b.title.length;
			});

			return scored.slice(0, 10);
		}

		displayResults(results) {
			if (!this.resultsList) return;

			this.hideLoading();
			this.hideNoResults();

			this.resultsList.replaceChildren();

			if (results.length === 0) {
				this.showNoResults();
				return;
			}

			for (const item of results) {
				const typeConfig = this.getTypeConfig(item.type);

				const link = document.createElement("a");
				link.href = this.escapeAttribute(item.url);
				link.className = "mpl-search-result-item";
				link.role = "option";

				const content = document.createElement("div");
				content.className = "mpl-search-result-content";

				const header = document.createElement("div");
				header.className = "mpl-search-result-header";

				const title = document.createElement("h3");
				title.className = "mpl-search-result-title";
				title.textContent = item.title;

				const type = document.createElement("span");
				type.className = `mpl-search-result-type ${typeConfig.badgeClass}`;
				type.textContent = typeConfig.label;

				header.appendChild(title);
				header.appendChild(type);

				const meta = document.createElement("div");
				meta.className = "mpl-search-result-meta";

				if (item.difficulty) {
					const span = document.createElement("span");
					span.textContent = item.difficulty;
					meta.appendChild(span);
				}

				if (Array.isArray(item.tags) && item.tags.length > 0) {
					const span = document.createElement("span");
					span.textContent =
						item.tags.slice(0, 3).join(", ") +
						(item.tags.length > 3 ? ` +${item.tags.length - 3}` : "");
					meta.appendChild(span);
				}

				content.appendChild(header);

				if (item.description) {
					const description = document.createElement("p");
					description.className = "mpl-search-result-description";
					description.textContent = item.description;
					content.appendChild(description);
				}

				if (meta.children.length > 0) {
					content.appendChild(meta);
				}

				link.appendChild(content);
				this.resultsList.appendChild(link);
			}

			this.showResults();
		}

		getTypeConfig(type) {
			const configs = {
				prompt: {
					label: "Prompt",
					badgeClass: "mpl-type-prompt",
				},
				tag: {
					label: "Tag",
					badgeClass: "mpl-type-tag",
				},
				page: {
					label: "Page",
					badgeClass: "mpl-type-page",
				},
			};

			return configs[type] ?? configs.page;
		}

		showResults() {
			if (this.results) {
				this.results.classList.remove("hidden");
			}
			if (this.input) {
				this.input.setAttribute("aria-expanded", "true");
			}
		}

		hideResults() {
			if (this.results) {
				this.results.classList.add("hidden");
			}
			if (this.input) {
				this.input.setAttribute("aria-expanded", "false");
			}
		}

		showLoading() {
			if (this.loading) this.loading.classList.remove("hidden");
			if (this.noResults) this.noResults.classList.add("hidden");
			if (this.resultsList) this.resultsList.replaceChildren();
			this.showResults();
		}

		hideLoading() {
			if (this.loading) this.loading.classList.add("hidden");
		}

		showNoResults() {
			if (this.noResults) this.noResults.classList.remove("hidden");
			if (this.loading) this.loading.classList.add("hidden");
			if (this.resultsList) this.resultsList.replaceChildren();
			this.showResults();
		}

		hideNoResults() {
			if (this.noResults) this.noResults.classList.add("hidden");
		}

		clearSearch() {
			if (this.input) {
				this.input.value = "";
				this.input.focus();
			}
			this.hideResults();
			if (this.clearBtn) {
				this.clearBtn.classList.add("hidden");
			}
		}

		handleArrowKeys(key) {
			if (!this.resultsList) return;
			const items = this.resultsList.querySelectorAll(".mpl-search-result-item");
			if (!items.length) return;

			const activeIndex = Array.from(items).findIndex((el) =>
				el.classList.contains("mpl-search-result-item--active"),
			);

			let nextIndex = 0;
			if (key === "ArrowDown") {
				nextIndex = activeIndex < items.length - 1 ? activeIndex + 1 : 0;
			} else {
				nextIndex = activeIndex > 0 ? activeIndex - 1 : items.length - 1;
			}

			items.forEach((el) =>
				el.classList.remove("mpl-search-result-item--active"),
			);

			const next = items[nextIndex];
			next.classList.add("mpl-search-result-item--active");
			next.scrollIntoView({ block: "nearest" });
		}

		handleEnterKey() {
			if (!this.resultsList) return;
			const active = this.resultsList.querySelector(".mpl-search-result-item--active");
			if (active) {
				active.click();
			}
		}

		escapeAttribute(value) {
			const div = document.createElement("div");
			div.textContent = String(value);
			return div.innerHTML;
		}
	}

	if (typeof window !== "undefined" && Array.isArray(searchData)) {
		const init = () => {
			document.querySelectorAll("[data-search-root]").forEach((root) => {
				new SearchBar(root, searchData);
			});
		};

		if (document.readyState === "loading") {
			document.addEventListener("DOMContentLoaded", init, { once: true });
		} else {
			init();
		}
	}
</script>

<style>
	.hidden {
		display: none !important;
	}

	.mpl-search-root {
		position: relative;
		min-width: 0;
	}

	.mpl-search-input-wrapper {
		display: flex;
		align-items: center;
		gap: 0.25rem;
		padding: 0.125rem 0.5rem;
		border-radius: 999px;
		border: 1px solid var(--color-border);
		background: var(--color-surface);
		color: var(--color-text-muted);
		min-width: 10rem;
		max-width: 20rem;
	}

	.mpl-search-icon {
		font-size: 0.875rem;
		opacity: 0.8;
	}

	.mpl-search-label {
		flex: 1;
	}

	.mpl-search-input {
		width: 100%;
		border: none;
		outline: none;
		background: transparent;
		color: var(--color-text);
		font-size: 0.875rem;
	}

	.mpl-search-input::placeholder {
		color: var(--color-text-muted);
	}

	.mpl-search-clear {
		border: none;
		background: transparent;
		cursor: pointer;
		color: var(--color-text-muted);
		padding: 0 0.25rem;
		font-size: 0.9rem;
	}

	.mpl-search-clear:hover,
	.mpl-search-clear:focus-visible {
		color: var(--color-accent);
	}

	.mpl-search-dropdown {
		position: absolute;
		top: calc(100% + 0.4rem);
		left: 0;
		right: 0;
		z-index: 20;
		max-height: 22rem;
		overflow-y: auto;
		padding: 0.25rem 0;
		border-radius: 0.75rem;
		border: 1px solid var(--color-border);
		background: var(--color-surface);
		color: var(--color-text);
		box-shadow: 0 18px 45px rgba(15, 23, 42, 0.3);
	}

	.mpl-search-state {
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		gap: 0.25rem;
		padding: 1.25rem;
		font-size: 0.875rem;
		color: var(--color-text-muted);
	}

	.mpl-search-spinner {
		width: 1.25rem;
		height: 1.25rem;
		border-radius: 999px;
		border: 2px solid rgba(148, 163, 184, 0.6);
		border-top-color: var(--color-accent);
		animation: mpl-spin 0.8s linear infinite;
	}

	.mpl-search-empty-title {
		font-weight: 600;
		margin: 0 0 0.125rem;
	}

	.mpl-search-empty-hint {
		margin: 0;
		font-size: 0.8rem;
	}

	.mpl-search-results-list {
		display: flex;
		flex-direction: column;
		gap: 0.25rem;
		padding: 0.25rem 0.35rem 0.4rem;
	}

	.mpl-search-result-item {
		display: block;
		padding: 0.6rem 0.7rem;
		text-decoration: none;
		color: var(--color-text);
		border-radius: 0.6rem;
	}

	.mpl-search-result-item:hover,
	.mpl-search-result-item:focus-visible {
		background: rgba(120, 113, 198, 0.12);
		outline: none;
	}

	.mpl-search-result-item:visited {
		color: var(--color-text);
	}

	.mpl-search-result-item--active {
		background: var(--color-accent);
		color: white;
	}

	.mpl-search-result-content {
		display: flex;
		flex-direction: column;
		gap: 0.3rem;
	}

	.mpl-search-result-header {
		display: flex;
		align-items: center;
		justify-content: space-between;
		gap: 0.5rem;
	}

	.mpl-search-result-title {
		font-size: 0.9rem;
		font-weight: 600;
		margin: 0;
	}

	.mpl-search-result-item:hover .mpl-search-result-title,
	.mpl-search-result-item:focus-visible .mpl-search-result-title {
		color: var(--color-accent);
	}

	.mpl-search-result-description {
		margin: 0;
		font-size: 0.8rem;
		color: var(--color-text-muted);
	}

	.mpl-search-result-meta {
		display: flex;
		flex-wrap: wrap;
		gap: 0.35rem 0.75rem;
		font-size: 0.75rem;
		color: var(--color-text-muted);
	}

	.mpl-search-result-meta span::before {
		content: "‚Ä¢ ";
		opacity: 0.6;
	}

	.mpl-search-result-meta span:first-child::before {
		content: "";
	}

	.mpl-search-result-type {
		font-size: 0.7rem;
		text-transform: uppercase;
		letter-spacing: 0.06em;
		padding: 0.125rem 0.5rem;
		border-radius: 999px;
		white-space: nowrap;
	}

	.mpl-type-prompt {
		background: rgba(59, 130, 246, 0.15);
		color: rgb(96, 165, 250);
	}

	.mpl-type-tag {
		background: rgba(249, 115, 22, 0.18);
		color: rgb(251, 146, 60);
	}

	.mpl-type-page {
		background: rgba(148, 163, 184, 0.18);
		color: rgb(148, 163, 184);
	}

	.visually-hidden {
		position: absolute;
		width: 1px;
		height: 1px;
		padding: 0;
		margin: -1px;
		overflow: hidden;
		clip: rect(0, 0, 0, 0);
		white-space: nowrap;
		border: 0;
	}

	@keyframes mpl-spin {
		to {
			transform: rotate(360deg);
		}
	}

	@media (max-width: 640px) {
		.mpl-search-input-wrapper {
			max-width: 100%;
		}

		.mpl-search-dropdown {
			left: 0;
			right: 0;
		}
	}
</style>

