---
import Layout from "../../layouts/Layout.astro";
import PageHeader from "../../components/PageHeader.astro";
import PromptCard from "../../components/PromptCard.astro";
import { getCollection } from "astro:content";

let prompts = await getCollection("prompts", ({ data }) => data.visibility === "public");

prompts = prompts.sort(
  (a, b) => new Date(b.data.updated_at).getTime() - new Date(a.data.updated_at).getTime(),
);

const tagSet = new Set<string>();
const authorSet = new Set<string>();
for (const entry of prompts) {
  entry.data.tags.forEach((t: string) => tagSet.add(t));
  authorSet.add(entry.data.author);
}
const tags = Array.from(tagSet).sort((a, b) => a.localeCompare(b));
const authors = Array.from(authorSet).sort((a, b) => a.localeCompare(b));
const difficulties = ["beginner", "intermediate", "advanced"] as const;
---

<Layout
  title="Prompts â€” My Prompt Library"
  description="Browse all curated prompts. Filter by tag, difficulty, and author."
>
  <PageHeader
    title="Prompts"
    description="Browse and filter prompts by tag, difficulty, or author. Every entry is a plain Markdown file in this repo."
  />

  <div class="mb-6 flex flex-wrap items-center gap-3 rounded-lg border border-[var(--color-border)] border-l-4 border-l-[var(--color-accent)] bg-[var(--color-accent-subtle)] p-4">
    <span class="text-xs font-medium uppercase tracking-wider text-[var(--color-muted)]">
      Filters
    </span>
    <form
      method="get"
      action="/prompts/"
      class="flex flex-wrap items-center gap-3"
      data-prompts-filter
    >
      <label for="filter-difficulty" class="sr-only">Difficulty</label>
      <select
        id="filter-difficulty"
        name="difficulty"
        class="rounded-md border border-[var(--color-border)] bg-[var(--color-background)] px-3 py-1.5 text-sm text-[var(--color-foreground)] focus:border-[var(--color-accent)]"
        aria-label="Filter by difficulty"
      >
        <option value="">All difficulties</option>
        {difficulties.map((d) => (
          <option value={d}>
            {d}
          </option>
        ))}
      </select>
      <label for="filter-author" class="sr-only">Author</label>
      <select
        id="filter-author"
        name="author"
        class="rounded-md border border-[var(--color-border)] bg-[var(--color-background)] px-3 py-1.5 text-sm text-[var(--color-foreground)] focus:border-[var(--color-accent)]"
        aria-label="Filter by author"
      >
        <option value="">All authors</option>
        {authors.map((a) => (
          <option value={a}>
            {a}
          </option>
        ))}
      </select>
      <label for="filter-tag" class="sr-only">Tag</label>
      <select
        id="filter-tag"
        name="tag"
        class="rounded-md border border-[var(--color-border)] bg-[var(--color-background)] px-3 py-1.5 text-sm text-[var(--color-foreground)] focus:border-[var(--color-accent)]"
        aria-label="Filter by tag"
      >
        <option value="">All tags</option>
        {tags.map((t) => (
          <option value={t}>
            {t}
          </option>
        ))}
      </select>
      <button
        type="submit"
        class="rounded-md bg-[var(--color-accent)] px-3 py-1.5 text-sm font-medium text-white hover:opacity-90"
      >
        Apply
      </button>
    </form>
  </div>

  <ul
    class="list-none space-y-4 p-0"
    aria-label="List of prompts"
    data-prompts-list
  >
    {prompts.map((entry) => (
      <li
        data-prompt-item
        data-difficulty={entry.data.difficulty}
        data-author={entry.data.author}
        data-tags={entry.data.tags.join(",")}
      >
        <PromptCard entry={entry} />
      </li>
    ))}
  </ul>

  <p
    id="prompts-empty"
    class="mt-4 hidden text-[var(--color-muted)]"
  >
    No prompts found for the selected filters.
  </p>
</Layout>

<script>
  if (typeof window !== "undefined") {
    const form = document.querySelector("[data-prompts-filter]");
    const selectDifficulty = document.getElementById(
      "filter-difficulty",
    ) as HTMLSelectElement | null;
    const selectAuthor = document.getElementById("filter-author") as HTMLSelectElement | null;
    const selectTag = document.getElementById("filter-tag") as HTMLSelectElement | null;
    /** @type {HTMLUListElement | null} */
    const list = document.querySelector("[data-prompts-list]");
    /** @type {HTMLElement | null} */
    const emptyEl = document.getElementById("prompts-empty");

    /** @type {HTMLElement[]} */
    const items = list ? Array.from(list.querySelectorAll("[data-prompt-item]")) : [];

    function applyFiltersFromState() {
      const difficulty = (selectDifficulty && selectDifficulty.value) || "";
      const author = (selectAuthor && selectAuthor.value) || "";
      const tag = (selectTag && selectTag.value) || "";

      let visibleCount = 0;

      items.forEach((item) => {
        const itemDifficulty = item.getAttribute("data-difficulty") || "";
        const itemAuthor = item.getAttribute("data-author") || "";
        const rawTags = item.getAttribute("data-tags") || "";
        const itemTags = rawTags
          .split(",")
          .map((t) => t.trim())
          .filter(Boolean);

        const matchesDifficulty = !difficulty || itemDifficulty === difficulty;
        const matchesAuthor = !author || itemAuthor === author;
        const matchesTag = !tag || itemTags.includes(tag);

        const visible = matchesDifficulty && matchesAuthor && matchesTag;
        item.classList.toggle("hidden", !visible);
        if (visible) visibleCount += 1;
      });

      if (emptyEl) {
        emptyEl.classList.toggle("hidden", visibleCount !== 0);
      }
    }

    function syncStateFromUrl() {
      const params = new URL(window.location.href).searchParams;
      const difficulty = params.get("difficulty") || "";
      const author = params.get("author") || "";
      const tag = params.get("tag") || "";

      if (selectDifficulty) selectDifficulty.value = difficulty;
      if (selectAuthor) selectAuthor.value = author;
      if (selectTag) selectTag.value = tag;
    }

    function updateUrlFromState() {
      const params = new URLSearchParams(window.location.search);
      const difficulty = (selectDifficulty && selectDifficulty.value) || "";
      const author = (selectAuthor && selectAuthor.value) || "";
      const tag = (selectTag && selectTag.value) || "";

      if (difficulty) params.set("difficulty", difficulty);
      else params.delete("difficulty");

      if (author) params.set("author", author);
      else params.delete("author");

      if (tag) params.set("tag", tag);
      else params.delete("tag");

      const query = params.toString();
      const newUrl = query ? `${window.location.pathname}?${query}` : window.location.pathname;
      window.history.replaceState(null, "", newUrl);
    }

    function handleChange() {
      updateUrlFromState();
      applyFiltersFromState();
    }

    // Initialize from current URL, then apply filters.
    syncStateFromUrl();
    applyFiltersFromState();

    [selectDifficulty, selectAuthor, selectTag].forEach((el) => {
      el?.addEventListener("change", handleChange);
    });

    form?.addEventListener("submit", (event) => {
      event.preventDefault();
      handleChange();
    });
  }
</script>
